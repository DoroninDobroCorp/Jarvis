# Правила автоматизации Jarvis

## Основной принцип
**Всегда используйте неинвазивные методы автоматизации, которые не двигают системный курсор и не мешают работе пользователя на других мониторах.**

---
## Правила логирования (ОБЯЗАТЕЛЬНО)

Логируем максимально подробно при любой возможности. Цели: воспроизводимость, диагностика, анализ поведения. **Не стесняйтесь токенов и API-вызовов — детальное логирование важнее экономии.**

- **[уровни]** Используйте уровни: DEBUG (детали шагов), INFO (основные события), WARNING (нештатные, но терпимые ситуации), ERROR (ошибки с трейсом), CRITICAL (фейлы всего сценария).
- **[структура]** Каждый шаг сценария логировать: входные данные (анонимиз.), действие, результат, тайминги, артефакты (пути к скринам/файлам).
- **[пер‑командный лог]** Для каждой пользовательской команды создавать отдельный файл лога в `logs/` (реализовано в `logger_setup.py`).
- **[корреляция]** В каждом сообщении лога указывать идентификатор команды/сессии (хеш команды или UUID), чтобы связывать события.
- **[тайминги]** Логировать начало/конец операций и длительность (API‑вызовы, скриншоты, навигация, клики, распознавание).
- **[метрики API]** Фиксировать количество и тип вызовов внешних API (Gemini/OpenAI/и т.д.), ответы/коды статуса, ретраи. Не беспокойтесь о стоимости — логируйте всё.
- **[маскирование]** Никогда не логировать секреты: токены, ключи, куки, полные личные данные. Маскировать: `****`.
- **[ошибки]** Всегда писать stack trace (`exc_info=True`) и контекст (какой шаг выполнялся, какие параметры были заданы — без секретов).
- **[артефакты]** Сохранять пути к скриншотам, временным файлам, версиям конфигурации.
- **[тогглы]** Управлять подробностью логирования переменными окружения (например, `LOG_LEVEL`, `LOG_API_COSTS=1`).
- **[PII]** При логировании пользовательского ввода — убирать/маскировать персональные данные, если они не критичны для диагностики.

---

## Правила документации (ОБЯЗАТЕЛЬНО)

**При создании новых файлов или существенном изменении существующих — ВСЕГДА обновляйте `README.md`**

- **[новые файлы]** Добавить описание файла в соответствующую секцию README (основные модули / тесты / утилиты).
- **[изменение назначения]** Если файл меняет роль/функциональность — обновить его описание в README.
- **[удаление]** При удалении файла — убрать его из README.
- **[новые директории]** Документировать назначение новых папок в секции "Директории".
- **[зависимости]** При добавлении новых библиотек в `requirements.txt` — отметить в README, если они критичны для понимания архитектуры.
- **[актуальность]** README должен быть единственным источником правды о структуре проекта.

**Формат описания файла в README:**
```markdown
- **`имя_файла.py`** - Краткое описание назначения (1-2 предложения)
```

---

## Правила тестов (ОБЯЗАТЕЛЬНО)

**Все тесты размещаются ТОЛЬКО в директории `tests/`**

- **[размещение]** Все файлы тестов (`*_test.py`, `test_*.py`, `*_tests.py`) должны быть в папке `tests/`.
- **[маркировка регулярных]** Если тест планируется **регулярно использовать** (после изменений, для проверки функциональности), добавить комментарий в первую строку:
  ```python
  # РЕГУЛЯРНЫЙ ТЕСТ: Краткое описание когда использовать
  ```
- **[временные тесты]** Тесты без маркера `# РЕГУЛЯРНЫЙ ТЕСТ` считаются временными — можно удалять при необходимости.
- **[импорты]** Все тесты в `tests/` должны добавлять родительскую директорию в путь:
  ```python
  import sys
  from pathlib import Path
  sys.path.insert(0, str(Path(__file__).parent.parent))
  ```
- **[запуск]** Тесты запускаются из корня проекта: `./venv/bin/python tests/test_name.py`
- **[README]** Обязательно разделять в README регулярные и временные тесты.

**Пример регулярного теста:**
```python
# РЕГУЛЯРНЫЙ ТЕСТ: Проверка базовых компонентов после изменений
"""
Быстрый тест всех основных модулей
"""
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

# ... код теста
```

**Пример временного теста:**
```python
"""
Тест новой фичи X (можно удалить после стабилизации)
"""
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

# ... код теста
```

---

## Приоритеты методов автоматизации

### 1. **API и скриптовые интерфейсы** (Высший приоритет)
Всегда используйте, когда доступно:
- **AppleScript** для нативных macOS приложений (Spotify, Calculator, Finder, etc.)
- **JavaScript Automation (JXA)** для приложений с поддержкой
- **Официальные API** приложений (Spotify Web API, Discord API, etc.)
- **URL-схемы** для быстрого запуска и управления

**Примеры:**
```applescript
# Spotify
tell application "Spotify"
    play track "spotify:track:..."
    set sound volume to 50
end tell

# Safari
tell application "Safari"
    set URL of document 1 to "https://example.com"
end tell
```

**Преимущества:**
- ✅ Не двигает курсор
- ✅ Не требует фокуса окна
- ✅ Быстро и надежно
- ✅ Не мешает пользователю

---

### 2. **DOM-автоматизация браузера** (Высокий приоритет)
Для веб-задач используйте:
- **Playwright** (рекомендуется)
- **Selenium**
- **Chrome DevTools Protocol (CDP)**

**Пример:**
```python
from playwright.async_api import async_playwright

async with async_playwright() as p:
    browser = await p.chromium.launch()
    page = await browser.new_page()
    await page.goto("https://youtube.com")
    await page.fill('input[name="search_query"]', 'котики')
    await page.click('button#search-icon-legacy')
```

**Преимущества:**
- ✅ Не двигает системный курсор
- ✅ Точное взаимодействие с элементами (по селекторам, не координатам)
- ✅ Надежнее координат (адаптируется к изменениям интерфейса)
- ✅ Пользователь может работать параллельно

---

### 3. **Accessibility (AXUIElement)** (Средний приоритет)
Для нативных приложений без AppleScript поддержки:
- Доступ к элементам UI через Accessibility API
- Метод `AXPress` для нажатия без движения курсора

**Ограничения:**
- Требует включенного Accessibility доступа
- Может требовать фокуса окна
- Сложнее в реализации

---

### 4. **Координатные клики (pyautogui)** (НИЗШИЙ приоритет)
**ИСПОЛЬЗУЙТЕ ТОЛЬКО КАК ПОСЛЕДНИЙ ВАРИАНТ!**

Когда применять:
- Нет API, AppleScript, DOM доступа
- Элемент не доступен через Accessibility
- Временное решение для прототипирования

**Проблемы:**
- ❌ Двигает системный курсор → мешает пользователю
- ❌ Ненадежно (зависит от разрешения, масштаба, позиции окна)
- ❌ Требует фокуса окна
- ❌ Ломается при изменении интерфейса

**Если неизбежно:**
- Предупреждайте пользователя
- Детектируйте idle (пользователь не работает)
- Добавьте горячую клавишу "пауза"
- Ограничьте координаты только вторым монитором

---

## Конкретные рекомендации по приложениям

### Веб (Chrome, Safari, Firefox)
- ✅ **Используйте:** Playwright, Selenium
- ❌ **Не используйте:** Координаты, клики через pyautogui

### Spotify
- ✅ **Используйте:** AppleScript или Spotify Web API
- ❌ **Не используйте:** Координаты

### YouTube, Google, любые сайты
- ✅ **Используйте:** Playwright с селекторами элементов
- ❌ **Не используйте:** Координаты

### Calculator, Finder, Notes
- ✅ **Используйте:** AppleScript
- ⚠️ **Допустимо:** Accessibility API
- ❌ **Избегайте:** Координаты

### Zoom, Discord, Slack
- ✅ **Используйте:** API приложения (если есть)
- ⚠️ **Допустимо:** URL-схемы для запуска
- ❌ **Последний вариант:** Координаты

---

## Правила кода

### 1. Используйте селекторы, а не координаты
```python
# ❌ ПЛОХО
screen.click_at(500, 300)

# ✅ ХОРОШО
await page.click('button#search')
await page.fill('input[name="query"]', 'текст')
```

### 2. Проверяйте доступность API перед реализацией
```python
# ❌ ПЛОХО - сразу в координаты
def open_spotify():
    screen.click_at(100, 100)

# ✅ ХОРОШО - проверка AppleScript
def open_spotify():
    subprocess.run(['osascript', '-e', 'tell application "Spotify" to play'])
```

### 3. Изолируйте координатную логику
```python
# Если АБСОЛЮТНО необходимо использовать координаты:
class LegacyCoordinateController:
    """DEPRECATED: Использовать только для приложений без API"""
    
    def click_with_warning(self, x, y):
        logger.warning("КООРДИНАТНЫЙ КЛИК: Может помешать пользователю!")
        # ...
```

---

## Миграционная стратегия

### Текущее состояние
- ❌ `screen_manager.py` использует pyautogui для всего
- ❌ `full_scenario_test.py` кликает по координатам

### План миграции

1. **Браузерные сценарии** → Playwright
   - Создать `web_automation.py`
   - Заменить все вызовы `screen.click_at()` на DOM-методы
   - Оставить `browser_controller.py` только для открытия/перемещения окна

2. **Spotify** → AppleScript
   - Создать `spotify_controller.py`
   - Реализовать play/pause/search через AppleScript

3. **Другие приложения** → Индивидуально
   - Сначала проверить доступность API/AppleScript
   - Если нет → Accessibility API
   - Координаты — только крайний случай

---

## Тестирование

При разработке новых сценариев:
- ✅ Запускайте на втором мониторе
- ✅ Работайте параллельно на первом мониторе
- ✅ Проверяйте, что курсор не "убегает"
- ✅ Тестируйте разные разрешения экрана

---

## Выводы

**Золотое правило:** Если можете тыкать не по координатам, а по конкретным кнопкам/элементам — ВСЕГДА делайте это!

**Иерархия:**  
API/AppleScript > DOM (Playwright) > Accessibility > Координаты (крайний случай)
